---
name: build-and-test-differential
"on":
  workflow_call:
    inputs:
      container:
        required: true
        type: string
      # Why is it a JSON string?
      # https://github.com/orgs/community/discussions/11692#discussioncomment-3541856
      runner:
        default: "['ubuntu-24.04']"
        required: false
        type: string
      rosdistro:
        default: humble
        required: false
        type: string
      run-condition:
        default: true
        required: false
        type: boolean
      container-suffix:
        required: false
        default: "-cuda"
        type: string
      build-pre-command:
        required: false
        default: ""
        type: string
    secrets:
      codecov-token:
        required: false

env:
  CCACHE_DIR: /root/.ccache

jobs:
  build-and-test-differential:
    if: ${{ inputs.run-condition }}
    runs-on: ${{ fromJson(inputs.runner) }}
    container: ${{ inputs.container }}${{ inputs.container-suffix }}
    steps:
      - name: Set PR fetch depth
        run: >
          echo "PR_FETCH_DEPTH=$(( ${{
          github.event.pull_request.commits || 1 }} + 1 ))"
          >> "${GITHUB_ENV}"
        shell: bash

      - name: Setup ccache environment
        run: |
          echo "CCACHE_DIR=/root/.ccache" >> "${GITHUB_ENV}"
          if command -v ccache &> /dev/null; then
            echo "CC=/usr/lib/ccache/gcc" >> "${GITHUB_ENV}"
            echo "CXX=/usr/lib/ccache/g++" >> "${GITHUB_ENV}"
            echo "ccache is available, enabling ccache"
          else
            echo "ccache is not available, using default compilers"
          fi
        shell: bash

      - name: Checkout PR branch and all PR commits
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: ${{ env.PR_FETCH_DEPTH }}

      - name: Show disk space before the tasks
        run: df -h
        shell: bash

      - name: Show machine specs
        run: lscpu && free -h
        shell: bash

      - name: Check CUDA availability
        run: |
          if command -v nvidia-smi &> /dev/null; then
            echo "CUDA is available"
            nvidia-smi
          else
            echo "CUDA is not available"
          fi
        shell: bash

      - name: Remove exec_depend
        # yamllint disable-line rule:line-length
        uses: autowarefoundation/autoware-github-actions/remove-exec-depend@v1

      - name: Create ccache directory and check availability
        run: |
          mkdir -p ${CCACHE_DIR}
          if command -v ccache &> /dev/null; then
            echo "ccache is available"
            du -sh ${CCACHE_DIR} && ccache -s
            echo "CCACHE_AVAILABLE=true" >> "${GITHUB_ENV}"
          else
            echo "ccache is not available, skipping ccache setup"
            du -sh ${CCACHE_DIR}
            echo "CCACHE_AVAILABLE=false" >> "${GITHUB_ENV}"
          fi
        shell: bash

      - name: Restore ccache
        if: ${{ env.CCACHE_AVAILABLE == 'true' }}
        uses: actions/cache/restore@v4
        with:
          path: |
            /root/.ccache
          key: >
            ccache-main-${{ runner.arch }}-${{ inputs.rosdistro }}-${{
            github.event.pull_request.base.sha || github.sha }}
          restore-keys: |
            ccache-main-${{ runner.arch }}-${{ inputs.rosdistro }}-

      - name: Show ccache stats before build and reset stats
        run: |
          if [[ "${CCACHE_AVAILABLE}" == "true" ]]; then
            du -sh ${CCACHE_DIR} && ccache -s
            ccache --zero-stats
          else
            echo "ccache is not available, skipping ccache stats"
          fi
        shell: bash

      - name: Export CUDA state as a variable for adding to cache key
        run: |
          build_type_cuda_state=nocuda
          if [[ "${{ inputs.container-suffix }}" == "-cuda" ]]; then
            build_type_cuda_state=cuda
          fi
          echo "BUILD_TYPE_CUDA_STATE=$build_type_cuda_state" >> "${GITHUB_ENV}"
          echo "::notice::BUILD_TYPE_CUDA_STATE=$build_type_cuda_state"
        shell: bash

      - name: Prepare build_depends.repos file (main branch)
        if: ${{ github.event.pull_request.base.ref != 'humble' }}
        run: |
          if [ -f build_depends_nightly.repos ]; then
            cat build_depends_humble.repos build_depends_nightly.repos \
              > build_depends.repos
          else
            cp build_depends_humble.repos build_depends.repos
          fi
        shell: bash

      - name: Prepare build_depends.repos file (humble branch)
        if: ${{ github.event.pull_request.base.ref == 'humble' }}
        run: cp build_depends_humble.repos build_depends.repos
        shell: bash

      - name: Install dependencies
        run: |
          if [ -f "/setup.sh" ]; then
            . /setup.sh
          fi
          # Install essential build tools first
          apt-get update && apt-get install -y \
            build-essential \
            gcc \
            g++ \
            cpp \
            cmake \
            make \
            libc6-dev \
            linux-libc-dev \
            binutils \
            gcc-11 \
            g++-11 \
            cpp-11
          # Install vcs if not available
          if ! command -v vcs &> /dev/null; then
            echo "Installing python3-vcstool"
            apt-get install -y python3-vcstool
          fi
          # Try rosdep update with retry logic
          echo "Attempting rosdep update with retry logic..."
          for i in {1..3}; do
            echo "Attempt $i of 3"
            rosdep_update_cmd="rosdep update --include-eol-distros"
            if DEBIAN_FRONTEND=noninteractive ${rosdep_update_cmd}; then
              echo "rosdep update succeeded"
              break
            else
              echo "rosdep update failed, attempt $i"
              if [ $i -eq 3 ]; then
                echo "All rosdep update attempts failed, continuing"
                echo "Installing dependencies manually..."
                apt-get update
                apt-get install -y \
                  libeigen3-dev \
                  libstb-dev \
                  nlohmann-json3-dev \
                  ros-${{ inputs.rosdistro }}-geometry-msgs \
                  ros-${{ inputs.rosdistro }}-nav-msgs \
                  ros-${{ inputs.rosdistro }}-sensor-msgs \
                  ros-${{ inputs.rosdistro }}-tf2-eigen \
                  ros-${{ inputs.rosdistro }}-tf2-ros \
                  ros-${{ inputs.rosdistro }}-rclcpp \
                  ros-${{ inputs.rosdistro }}-rosbag2-cpp \
                  ros-${{ inputs.rosdistro }}-eigen3-cmake-module
                # CUDA packages are optional and may not be available
                cuda_msg="CUDA packages not available, continuing without them"
                apt-get install -y libcuda-dev libnvinfer-dev || \
                  echo "${cuda_msg}"
                break
              fi
              sleep $((i * 10))  # Wait between attempts
            fi
          done
          # Try rosdep install if rosdep update succeeded
          rosdep_path="autoware_tensorrt_vad"
          rosdep_distro="${{ inputs.rosdistro }}"
          if rosdep check --from-paths ${rosdep_path} \
              --ignore-src --rosdistro ${rosdep_distro} 2>/dev/null; then
            echo "Running rosdep install..."
            DEBIAN_FRONTEND=noninteractive rosdep install -yqq \
              --from-paths ${rosdep_path} \
              --ignore-src --rosdistro ${rosdep_distro} || true
          else
            echo "Skipping rosdep install due to previous failures"
          fi
        shell: bash

      - name: Build autoware_tensorrt_vad
        run: |
          if [ -f "/setup.sh" ]; then
            . /setup.sh
          fi
          # Source ROS2 environment
          source /opt/ros/${{ inputs.rosdistro }}/setup.bash
          # Install ROS2 build dependencies
          apt-get update && apt-get install -y \
            ros-${{ inputs.rosdistro }}-ament-cmake \
            ros-${{ inputs.rosdistro }}-ament-cmake-core \
            ros-${{ inputs.rosdistro }}-ament-lint-auto \
            ros-${{ inputs.rosdistro }}-ament-lint-common
          # Verify and fix compiler installation
          echo "Checking compiler installation..."
          which gcc || echo "gcc not found"
          which g++ || echo "g++ not found"
          gcc --version || echo "gcc version check failed"
          echo "PATH: $PATH"
          # Find and verify cc1 location
          cc1_path=$(find /usr -name "cc1" 2>/dev/null | head -1)
          if [ -n "$cc1_path" ]; then
            echo "Found cc1 at: $cc1_path"
            cc1_dir=$(dirname "$cc1_path")
            export PATH="$cc1_dir:$PATH"
          else
            echo "cc1 not found, installing gcc-11 specifically"
            apt-get install -y gcc-11 g++-11
            # Try to find cc1 again
            cc1_path=$(find /usr -name "cc1" 2>/dev/null | head -1)
            if [ -n "$cc1_path" ]; then
              echo "Found cc1 at: $cc1_path"
              cc1_dir=$(dirname "$cc1_path")
              export PATH="$cc1_dir:$PATH"
            fi
          fi
          # Set explicit compiler paths
          export CC=/usr/bin/gcc
          export CXX=/usr/bin/g++
          # Add gcc libexec directories to PATH
          for gcc_dir in /usr/lib/gcc/x86_64-linux-gnu/*; do
            if [ -d "$gcc_dir" ]; then
              export PATH="$gcc_dir:$PATH"
            fi
          done
          # Alternative: try to fix gcc installation if still broken
          test_cmd="echo 'int main(){return 0;}' | \$CC -x c - -o /tmp/test"
          if ! eval "$test_cmd" 2>/dev/null; then
            echo "Compiler still broken, trying alternative fixes..."
            # Reinstall gcc completely
            apt-get remove -y gcc g++ cpp
            apt-get autoremove -y
            apt-get install -y gcc-11 g++-11 cpp-11
            update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 100
            update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 100
            update-alternatives --install /usr/bin/cpp cpp /usr/bin/cpp-11 100
            export CC=/usr/bin/gcc-11
            export CXX=/usr/bin/g++-11
            # Update PATH again
            for gcc_dir in /usr/lib/gcc/x86_64-linux-gnu/*; do
              if [ -d "$gcc_dir" ]; then
                export PATH="$gcc_dir:$PATH"
              fi
            done
          fi
          echo "CC=${CC}, CXX=${CXX}"
          echo "Updated PATH: $PATH"
          # Test compiler functionality
          echo "Testing compiler..."
          echo 'int main(){return 0;}' > test.c
          $CC -c test.c -o test.o && echo "Compiler test passed" || \
            echo "Compiler test failed"
          rm -f test.c test.o
          # Import build_depends repositories
          if [ -f build_depends.repos ]; then
            mkdir -p dependency_ws/src
            vcs import dependency_ws/src < build_depends.repos
            # Source ROS2 environment again for dependency build
            source /opt/ros/${{ inputs.rosdistro }}/setup.bash
            # Build dependencies first with proper environment
            cd dependency_ws
            colcon build --cmake-args \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_C_COMPILER=${CC} \
              -DCMAKE_CXX_COMPILER=${CXX} \
              --packages-up-to autoware_cmake autoware_msgs
            source install/setup.bash
            cd ..
          fi
          # Build the target package
          colcon build --cmake-args \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER=${CC} \
            -DCMAKE_CXX_COMPILER=${CXX} \
            --packages-select autoware_tensorrt_vad
        shell: bash

      - name: Show ccache stats after build
        run: |
          if [[ "${CCACHE_AVAILABLE}" == "true" ]]; then
            du -sh ${CCACHE_DIR} && ccache -s
          else
            echo "ccache is not available, skipping ccache stats"
          fi
        shell: bash

      - name: Test autoware_tensorrt_vad
        id: test
        run: |
          if [ -f "/setup.sh" ]; then
            . /setup.sh
          fi
          # Source the built packages
          if [ -f dependency_ws/install/setup.bash ]; then
            . dependency_ws/install/setup.bash
          fi
          if [ -f install/setup.bash ]; then
            . install/setup.bash
          fi
          # Run tests
          colcon test --packages-select autoware_tensorrt_vad
          # Check test results
          colcon test-result --verbose
        shell: bash

      - name: Upload coverage to CodeCov
        if: ${{ steps.test.outputs.coverage-report-files != '' }}
        uses: codecov/codecov-action@v4
        with:
          files: ${{ steps.test.outputs.coverage-report-files }}
          fail_ci_if_error: false
          verbose: true
          flags: differential${{ inputs.container-suffix }}
          token: ${{ secrets.codecov-token }}

      - name: Show disk space after the tasks
        run: df -h
        shell: bash
