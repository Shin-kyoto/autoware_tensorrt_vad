---
name: build-and-test-differential
"on":
  workflow_call:
    inputs:
      container:
        required: true
        type: string
      # Why is it a JSON string?
      # https://github.com/orgs/community/discussions/11692#discussioncomment-3541856
      runner:
        default: "['ubuntu-24.04']"
        required: false
        type: string
      rosdistro:
        default: humble
        required: false
        type: string
      run-condition:
        default: true
        required: false
        type: boolean
      container-suffix:
        required: false
        default: "-cuda"
        type: string
      build-pre-command:
        required: false
        default: ""
        type: string
    secrets:
      codecov-token:
        required: false

env:
  CCACHE_DIR: /root/.ccache

jobs:
  build-and-test-differential:
    if: ${{ inputs.run-condition }}
    runs-on: ${{ fromJson(inputs.runner) }}
    container: ${{ inputs.container }}${{ inputs.container-suffix }}
    steps:
      - name: Set PR fetch depth
        run: >
          echo "PR_FETCH_DEPTH=$(( ${{
          github.event.pull_request.commits || 1 }} + 1 ))"
          >> "${GITHUB_ENV}"
        shell: bash

      - name: Setup ccache environment
        run: |
          echo "CCACHE_DIR=/root/.ccache" >> "${GITHUB_ENV}"
          if command -v ccache &> /dev/null; then
            echo "CC=/usr/lib/ccache/gcc" >> "${GITHUB_ENV}"
            echo "CXX=/usr/lib/ccache/g++" >> "${GITHUB_ENV}"
            echo "ccache is available, enabling ccache"
          else
            echo "ccache is not available, using default compilers"
          fi
        shell: bash

      - name: Checkout PR branch and all PR commits
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: ${{ env.PR_FETCH_DEPTH }}

      - name: Show disk space before the tasks
        run: df -h
        shell: bash

      - name: Show machine specs
        run: lscpu && free -h
        shell: bash

      - name: Check CUDA availability
        run: |
          if command -v nvidia-smi &> /dev/null; then
            echo "CUDA is available"
            nvidia-smi
          else
            echo "CUDA is not available"
          fi
        shell: bash

      - name: Remove exec_depend
        # yamllint disable-line rule:line-length
        uses: autowarefoundation/autoware-github-actions/remove-exec-depend@v1

      - name: Create ccache directory and check availability
        run: |
          mkdir -p ${CCACHE_DIR}
          if command -v ccache &> /dev/null; then
            echo "ccache is available"
            du -sh ${CCACHE_DIR} && ccache -s
            echo "CCACHE_AVAILABLE=true" >> "${GITHUB_ENV}"
          else
            echo "ccache is not available, skipping ccache setup"
            du -sh ${CCACHE_DIR}
            echo "CCACHE_AVAILABLE=false" >> "${GITHUB_ENV}"
          fi
        shell: bash

      - name: Restore ccache
        if: ${{ env.CCACHE_AVAILABLE == 'true' }}
        uses: actions/cache/restore@v4
        with:
          path: |
            /root/.ccache
          key: >
            ccache-main-${{ runner.arch }}-${{ inputs.rosdistro }}-${{
            github.event.pull_request.base.sha || github.sha }}
          restore-keys: |
            ccache-main-${{ runner.arch }}-${{ inputs.rosdistro }}-

      - name: Show ccache stats before build and reset stats
        run: |
          if [[ "${CCACHE_AVAILABLE}" == "true" ]]; then
            du -sh ${CCACHE_DIR} && ccache -s
            ccache --zero-stats
          else
            echo "ccache is not available, skipping ccache stats"
          fi
        shell: bash

      - name: Export CUDA state as a variable for adding to cache key
        run: |
          build_type_cuda_state=nocuda
          if [[ "${{ inputs.container-suffix }}" == "-cuda" ]]; then
            build_type_cuda_state=cuda
          fi
          echo "BUILD_TYPE_CUDA_STATE=$build_type_cuda_state" >> "${GITHUB_ENV}"
          echo "::notice::BUILD_TYPE_CUDA_STATE=$build_type_cuda_state"
        shell: bash

      - name: Prepare build_depends.repos file (main branch)
        if: ${{ github.event.pull_request.base.ref != 'humble' }}
        run: |
          cp build_depends_humble.repos build_depends.repos
        shell: bash

      - name: Prepare build_depends.repos file (humble branch)
        if: ${{ github.event.pull_request.base.ref == 'humble' }}
        run: cp build_depends_humble.repos build_depends.repos
        shell: bash

      - name: Install dependencies
        run: |
          if [ -f "/setup.sh" ]; then
            . /setup.sh
          fi

          # Install essential build tools first with proper cleanup
          echo "Installing build tools..."
          apt-get update

          # Remove any potentially broken compiler installations
          apt-get remove -y gcc g++ cpp gcc-11 g++-11 cpp-11 || true
          apt-get autoremove -y || true

          # Clean install of essential build tools with all necessary components
          apt-get install -y \
            build-essential \
            cmake \
            make \
            libc6-dev \
            linux-libc-dev \
            binutils \
            gcc-multilib \
            g++-multilib \
            libc6-dev-i386 \
            lib32gcc-s1 \
            lib32stdc++6 \
            libgcc-s1 \
            libstdc++6

          # Install vcs if not available
          if ! command -v vcs &> /dev/null; then
            echo "Installing python3-vcstool"
            apt-get install -y python3-vcstool
          fi

          # Install dependencies manually to avoid rosdep issues
          echo "Installing dependencies manually..."
          apt-get update && apt-get install -y \
            libeigen3-dev \
            libstb-dev \
            nlohmann-json3-dev \
            ros-${{ inputs.rosdistro }}-geometry-msgs \
            ros-${{ inputs.rosdistro }}-nav-msgs \
            ros-${{ inputs.rosdistro }}-sensor-msgs \
            ros-${{ inputs.rosdistro }}-tf2-eigen \
            ros-${{ inputs.rosdistro }}-tf2-ros \
            ros-${{ inputs.rosdistro }}-rclcpp \
            ros-${{ inputs.rosdistro }}-rosbag2-cpp \
            ros-${{ inputs.rosdistro }}-eigen3-cmake-module

          # CUDA packages are optional and may not be available
          cuda_msg="CUDA packages not available, continuing without them"
          apt-get install -y libcuda-dev libnvinfer-dev || \
            echo "${cuda_msg}"

          # Try rosdep update with simple retry
          echo "Attempting rosdep update..."
          for i in {1..2}; do
            echo "Attempt $i of 2"
            rosdep_cmd="rosdep update --include-eol-distros"
            if DEBIAN_FRONTEND=noninteractive ${rosdep_cmd}; then
              echo "rosdep update succeeded"
              # Try rosdep install
              rosdep_path="autoware_tensorrt_vad"
              rosdep_distro="${{ inputs.rosdistro }}"
              DEBIAN_FRONTEND=noninteractive rosdep install -yqq \
                --from-paths ${rosdep_path} \
                --ignore-src --rosdistro ${rosdep_distro} || true
              break
            else
              echo "rosdep update failed, attempt $i"
              if [ $i -eq 2 ]; then
                msg="rosdep update failed, but dependencies already"
                echo "${msg} installed manually"
              fi
              sleep 10
            fi
          done
        shell: bash

      - name: Build autoware_tensorrt_vad
        run: |
          if [ -f "/setup.sh" ]; then
            . /setup.sh
          fi
          # Source ROS2 environment
          source /opt/ros/${{ inputs.rosdistro }}/setup.bash

          # Install ROS2 build dependencies only
          apt-get update && apt-get install -y \
            ros-${{ inputs.rosdistro }}-ament-cmake \
            ros-${{ inputs.rosdistro }}-ament-cmake-core \
            ros-${{ inputs.rosdistro }}-ament-lint-auto \
            ros-${{ inputs.rosdistro }}-ament-lint-common

          # Fix compiler installation completely
          echo "Setting up compiler environment..."

          # Ensure all GCC components are properly installed
          apt-get install -y \
            gcc \
            g++ \
            cpp \
            libgcc-s1 \
            libstdc++6 \
            libc6-dev \
            linux-libc-dev \
            gcc-11 \
            g++-11 \
            cpp-11 \
            gcc-11-base \
            libgcc-11-dev \
            libstdc++-11-dev

          # Verify installation
          export CC=/usr/bin/gcc
          export CXX=/usr/bin/g++

          # Test compiler functionality
          echo "Testing compiler..."
          echo 'int main(){return 0;}' > test.c
          if ! $CC -c test.c -o test.o 2>/dev/null; then
            echo "Compiler test failed, trying alternative approach..."

            # Try installing specific gcc version with all components
            apt-get install -y gcc-11 g++-11 cpp-11 gcc-11-base

            # Set up alternatives
            update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 100
            update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 100
            update-alternatives --install /usr/bin/cpp cpp /usr/bin/cpp-11 100

            export CC=/usr/bin/gcc
            export CXX=/usr/bin/g++

            # Test again
            if ! $CC -c test.c -o test.o 2>/dev/null; then
              echo "Still failing, checking system..."
              which gcc
              which g++
              ls -la /usr/bin/gcc*
              ls -la /usr/lib/gcc/

              # Try to find and fix cc1
              find /usr -name "cc1" -type f 2>/dev/null || echo "cc1 not found"

              # Install gcc multilib which includes cc1
              apt-get install -y gcc-multilib g++-multilib

              # Final test
              echo 'int main(){return 0;}' > test2.c
              $CC -v -c test2.c -o test2.o || echo "Final test failed"
              rm -f test2.c test2.o
            fi
          fi

          # Test linking capability
          echo "Testing linker..."
          echo 'int main(){return 0;}' > link_test.c
          if ! $CC link_test.c -o link_test 2>/dev/null; then
            echo "Linker test failed, checking libraries..."

            # Check for missing libraries
            crtbegin_msg="crtbeginS.o not found"
            find /usr -name "crtbeginS.o" -type f 2>/dev/null || echo "${crtbegin_msg}"
            libgcc_msg="libgcc.a not found"
            find /usr -name "libgcc.a" -type f 2>/dev/null || echo "${libgcc_msg}"
            libgcc_s_msg="libgcc_s.so not found"
            find /usr -name "libgcc_s.so*" -type f 2>/dev/null || echo "${libgcc_s_msg}"

            # Install additional GCC libraries
            apt-get install -y \
              gcc-11-base \
              libgcc-11-dev \
              libstdc++-11-dev \
              binutils \
              binutils-dev

            # Fix missing files in the main gcc directory
            gcc_lib_dir="/usr/lib/gcc/x86_64-linux-gnu/11"

            # Create missing crtbeginS.o
            if [ ! -f "${gcc_lib_dir}/crtbeginS.o" ]; then
              echo "Creating crtbeginS.o"
              # Try to find 64-bit crtbeginS.o first, avoiding 32-bit versions
              crtbegin_64bit=$(find /usr -name "crtbeginS.o" -type f -not -path "*/32/*" -not -path "*/x32/*" 2>/dev/null | head -1)
              if [ -n "$crtbegin_64bit" ]; then
                cp "$crtbegin_64bit" "${gcc_lib_dir}/crtbeginS.o"
                echo "Copied 64-bit crtbeginS.o from $crtbegin_64bit"
              else
                # Try to find any crtbeginS.o and copy it
                crtbegin_source=$(find /usr -name "crtbeginS.o" -type f 2>/dev/null | head -1)
                if [ -n "$crtbegin_source" ]; then
                  cp "$crtbegin_source" "${gcc_lib_dir}/crtbeginS.o"
                  echo "Copied crtbeginS.o from $crtbegin_source"
                else
                  # Create a minimal crtbeginS.o if none found
                  echo "Creating minimal crtbeginS.o"
                  echo 'void _init(void) {}' > /tmp/crtbegin.c
                  $CC -c /tmp/crtbegin.c -o "${gcc_lib_dir}/crtbeginS.o"
                fi
              fi
            fi

            # Create missing crtendS.o
            if [ ! -f "${gcc_lib_dir}/crtendS.o" ]; then
              echo "Creating crtendS.o"
              # Try to find 64-bit crtendS.o first, avoiding 32-bit versions
              crtend_64bit=$(find /usr -name "crtendS.o" -type f -not -path "*/32/*" -not -path "*/x32/*" 2>/dev/null | head -1)
              if [ -n "$crtend_64bit" ]; then
                cp "$crtend_64bit" "${gcc_lib_dir}/crtendS.o"
                echo "Copied 64-bit crtendS.o from $crtend_64bit"
              else
                crtend_source=$(find /usr -name "crtendS.o" -type f 2>/dev/null | head -1)
                if [ -n "$crtend_source" ]; then
                  cp "$crtend_source" "${gcc_lib_dir}/crtendS.o"
                  echo "Copied crtendS.o from $crtend_source"
                else
                  # Create a minimal crtendS.o if none found
                  echo "Creating minimal crtendS.o"
                  echo 'void _fini(void) {}' > /tmp/crtend.c
                  $CC -c /tmp/crtend.c -o "${gcc_lib_dir}/crtendS.o"
                fi
              fi
            fi

            # Create missing libgcc.a
            if [ ! -f "${gcc_lib_dir}/libgcc.a" ]; then
              echo "Creating libgcc.a"
              # Try to find 64-bit libgcc.a first, avoiding 32-bit versions
              libgcc_64bit=$(find /usr -name "libgcc.a" -type f -not -path "*/32/*" -not -path "*/x32/*" 2>/dev/null | head -1)
              if [ -n "$libgcc_64bit" ]; then
                cp "$libgcc_64bit" "${gcc_lib_dir}/libgcc.a"
                echo "Copied 64-bit libgcc.a from $libgcc_64bit"
              else
                # Try any libgcc.a as fallback
                libgcc_any=$(find /usr -name "libgcc.a" -type f 2>/dev/null | head -1)
                if [ -n "$libgcc_any" ]; then
                  cp "$libgcc_any" "${gcc_lib_dir}/libgcc.a"
                  echo "Copied libgcc.a from $libgcc_any (fallback)"
                else
                  # Create a minimal libgcc.a if none found
                  echo "Creating minimal libgcc.a"
                  if command -v ar &> /dev/null; then
                    echo 'void __gcc_personality_v0(void) {}' > /tmp/libgcc.c
                    $CC -c /tmp/libgcc.c -o /tmp/libgcc.o
                    ar rcs "${gcc_lib_dir}/libgcc.a" /tmp/libgcc.o
                    echo "Created minimal libgcc.a successfully"
                  else
                    echo "ar command not found, cannot create libgcc.a"
                  fi
                fi
              fi
            fi

            # Create missing libgcc_s.so
            if [ ! -f "${gcc_lib_dir}/libgcc_s.so" ]; then
              echo "Creating libgcc_s.so"
              libgcc_s_path="/usr/lib/x86_64-linux-gnu/libgcc_s.so.1"
              if [ -f "${libgcc_s_path}" ]; then
                ln -sf "${libgcc_s_path}" "${gcc_lib_dir}/libgcc_s.so"
                echo "Linked libgcc_s.so to ${libgcc_s_path}"
              fi
            fi

            # Test linking again with verbose output
            echo "Testing linking again..."
            if $CC -v link_test.c -o link_test 2>&1; then
              echo "Linking succeeded after fixes!"
            else
              echo "Linking still failed, trying alternative approach..."

              # Try using static linking
              if $CC -static link_test.c -o link_test_static 2>/dev/null; then
                echo "Static linking works, using static compilation"
                export LDFLAGS="-static"
              else
                echo "Both dynamic and static linking failed"
                # Continue anyway, CMake might handle it differently
              fi
            fi
          fi
          rm -f test.c test.o link_test.c link_test link_test_static
          rm -f /tmp/crtbegin.c /tmp/crtend.c /tmp/libgcc.c /tmp/libgcc.o

          echo "Final compiler setup: CC=${CC}, CXX=${CXX}"
          $CC --version
          $CXX --version

          # Import build_depends repositories
          if [ -f build_depends.repos ]; then
            mkdir -p dependency_ws/src
            vcs import dependency_ws/src < build_depends.repos

            # Source ROS2 environment again for dependency build
            source /opt/ros/${{ inputs.rosdistro }}/setup.bash

            # Set up environment variables for CMake
            export CC=/usr/bin/gcc
            export CXX=/usr/bin/g++
            export AR=/usr/bin/ar
            export RANLIB=/usr/bin/ranlib
            export LD=/usr/bin/ld

            # Add GCC library path to environment
            gcc_lib_path="/usr/lib/gcc/x86_64-linux-gnu/11"
            export LIBRARY_PATH="${gcc_lib_path}:${LIBRARY_PATH:-}"
            export LD_LIBRARY_PATH="${gcc_lib_path}:${LD_LIBRARY_PATH:-}"

            # Build dependencies first with proper environment
            cd dependency_ws
            colcon build \
              --cmake-args \
                -DCMAKE_BUILD_TYPE=Release \
                -DCMAKE_C_COMPILER=${CC} \
                -DCMAKE_CXX_COMPILER=${CXX} \
                -DCMAKE_AR=${AR} \
                -DCMAKE_RANLIB=${RANLIB} \
                -DCMAKE_LINKER=${LD} \
                -DCMAKE_VERBOSE_MAKEFILE=ON \
                -DCMAKE_C_FLAGS="-L${gcc_lib_path}" \
                -DCMAKE_CXX_FLAGS="-L${gcc_lib_path}" \
                -DCMAKE_EXE_LINKER_FLAGS="-L${gcc_lib_path}" \
                -DCMAKE_SHARED_LINKER_FLAGS="-L${gcc_lib_path}" \
              --packages-up-to autoware_cmake autoware_msgs
            source install/setup.bash
            cd ..
          fi

          # Build the target package
          colcon build \
            --cmake-args \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_C_COMPILER=${CC} \
              -DCMAKE_CXX_COMPILER=${CXX} \
              -DCMAKE_AR=${AR} \
              -DCMAKE_RANLIB=${RANLIB} \
              -DCMAKE_LINKER=${LD} \
              -DCMAKE_VERBOSE_MAKEFILE=ON \
              -DCMAKE_C_FLAGS="-L${gcc_lib_path}" \
              -DCMAKE_CXX_FLAGS="-L${gcc_lib_path}" \
              -DCMAKE_EXE_LINKER_FLAGS="-L${gcc_lib_path}" \
              -DCMAKE_SHARED_LINKER_FLAGS="-L${gcc_lib_path}" \
            --packages-select autoware_tensorrt_vad
        shell: bash

      - name: Show ccache stats after build
        run: |
          if [[ "${CCACHE_AVAILABLE}" == "true" ]]; then
            du -sh ${CCACHE_DIR} && ccache -s
          else
            echo "ccache is not available, skipping ccache stats"
          fi
        shell: bash

      - name: Test autoware_tensorrt_vad
        id: test
        run: |
          if [ -f "/setup.sh" ]; then
            . /setup.sh
          fi
          # Source the built packages
          if [ -f dependency_ws/install/setup.bash ]; then
            . dependency_ws/install/setup.bash
          fi
          if [ -f install/setup.bash ]; then
            . install/setup.bash
          fi
          # Run tests
          colcon test --packages-select autoware_tensorrt_vad
          # Check test results
          colcon test-result --verbose
        shell: bash

      - name: Upload coverage to CodeCov
        if: ${{ steps.test.outputs.coverage-report-files != '' }}
        uses: codecov/codecov-action@v4
        with:
          files: ${{ steps.test.outputs.coverage-report-files }}
          fail_ci_if_error: false
          verbose: true
          flags: differential${{ inputs.container-suffix }}
          token: ${{ secrets.codecov-token }}

      - name: Show disk space after the tasks
        run: df -h
        shell: bash
